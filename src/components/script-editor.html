<!-- TODO Make a modal class -->
<template>
  <div class="modal">
    <div class="container">
      <div class="header"></div>
      <div class="dialog">
        <div class="sidebar">
          <api-docs />
        </div>

        <div class="editor">
          <div class="editor-header">
            <form>
              <div class="input-wrapper">
                <label>Script Name</label>
                <input
                  type="text"
                  class="label"
                  :value="label"
                  @input="onLabel($event)"
                />
              </div>
              <div class="input-wrapper">
                <label>Template</label>
                <select @input="onTemplate($event)">
                  <option value="">No Template</option>
                  <template :for="scripts">
                    <option :value="$value.id">{{$value.label}}</option>
                  </template>
                </select>
              </div>
            </form>
            <div :class='!!error ? "error " : "error hidden"'>
              {{(error || '').toString()}}
            </div>
          </div>
          <div class="code-box">
            <pre>
              <code id='visualizer' class="language-js"></code>
              <code 
                id='editor'
                contenteditable="true"
                tabindex="1" 
                @keydown="onKeyDown($event)"
                @keyup="onKeyUp($event)"
                @input="onCode($event)"
                @scroll="onScroll($event)"
              ></code>
            </pre>
          </div>
        </div>
      </div>
      <div class="footer">
        <div class="btn" @click="onSave()">{{ dirty ? "Save" : "Saved" }}</div>
        <div class="btn" @click="onCancel()">Close</div>
      </div>
    </div>
    <div class="overlay"></div>
  </div>
</template>

<script>
  class CodeEditor extends Component {
    constructor() {
      super();
    }

    static get observedProperties() {
      return ["app", "save", "label", "code", "scripts", "error", "dirty"];
    }

    connected() {
      this.dirty = false;
      this.selectionStart = 0;

      this.visualizer = this.querySelector("#visualizer");
      this.editor = this.querySelector("#editor");

      // this.listen("app", (app) => {
      //   console.log("App:", app)
      //   this.scripts = [...app.scripts];

      //   app.listen("scripts", (scripts) => {
      //     this.scripts = [...scripts];
      //   });
      // });

      this.scripts = this.app.scripts.filter((s) => !s.hidden);
      this.app.listen("scripts", (scripts) => {
        this.scripts = scripts.filter((s) => !s.hidden);
      });

      let nw = Prism.plugins.NormalizeWhitespace;
      this.code =
        nw.normalize(this.escapeHTML(this.code), {
          "left-trim": true,
          "right-trim": true,
          "remove-trailing": true,
          "remove-indent": true,
        }) + " ";

      this.visualizer.innerHTML = this.code;
      this.editor.innerHTML = this.code;
      Prism.highlightElement(this.visualizer);

      this.querySelectorAll(".sidebar code").forEach((c) => {
        Prism.highlightElement(c);
      });
    }

    onLabel(evt) {
      // let script = this.app.scripts[this.idx];
      this.label = evt.target.value;
      this.dirty = true;
      // this.app.updateScript(script.id, this.label, this.code);
    }

    onTemplate(evt) {
      let script = this.app.scripts.find((s) => +s.id === +evt.target.value);

      this.label = script.label + " Copy";
      this.code = this.normalize(this.escapeHTML(script.code)) + " ";

      this.visualizer.innerHTML = this.escapeHTML(this.code);
      this.editor.innerHTML = this.escapeHTML(this.code);
      Prism.highlightElement(this.visualizer);

      this.dirty = true;
    }

    escapeHTML(text) {
      return text.replace(/\</g, "&lt;").replace(/\>/g, "&gt;");
    }

    /**
     * [normalize This is kinda dumb, but in addition to using the
     *            prism whitespace normalizer, this function makes sure
     *            there's a trailing whitespace character which just
     *            basically fixes all the quirks of contentEditable]
     * @param  {[String]} text [the string to normalize]
     * @return {[Sype]}      [the normalized string]
     */
    normalize(text) {
      text = text.slice(0, -1);

      let nw = Prism.plugins.NormalizeWhitespace;
      let normalized = nw.normalize(this.escapeHTML(text), {
        "left-trim": false,
        "right-trim": false,
        "remove-trailing": false,
        "remove-indent": false,
      });

      return normalized + " ";
    }

    onKeyDown(evt) {
      let nw = Prism.plugins.NormalizeWhitespace;

      let el = evt.target;
      let code = el.innerText;

      let sel = document.getSelection();
      if (sel.rangeCount > 0) {
        let range = document.getSelection().getRangeAt(0);
        let preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(el);
        preCaretRange.setEnd(range.endContainer, range.endOffset);

        let startPos = preCaretRange.toString().length;
        let selectionSize = range.startOffset - range.endOffset;

        this.selectionStart = startPos;
      }

      if (evt.key === "Tab") {
        evt.preventDefault();
        let before_tab = code.slice(0, this.selectionStart);
        let after_tab = code.slice(this.selectionStart, code.length);

        let cursor_pos = this.selectionStart + 2;
        let tabbedCode = this.normalize(
          this.escapeHTML(before_tab + "  " + after_tab),
        );

        this.visualizer.innerHTML = this.escapeHTML(tabbedCode);
        this.editor.innerHTML = this.escapeHTML(tabbedCode);

        Prism.highlightElement(this.visualizer);
        this.code = tabbedCode;

        let selectedText = document.getSelection();
        let selectedRange = document.createRange();
        selectedRange.setStart(evt.target.childNodes[0], cursor_pos);
        selectedRange.collapse(true);
        selectedText.removeAllRanges();
        selectedText.addRange(selectedRange);
        evt.target.focus();

        this.dirty = true;
      }
    }

    onKeyUp(evt) {
      let el = evt.target;
      let code = el.innerText;
      let sel = document.getSelection();
      if (sel.rangeCount > 0) {
        let range = document.getSelection().getRangeAt(0);
        let preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(el);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        let startPos = preCaretRange.toString().length;
        let selectionSize = range.startOffset - range.endOffset;

        if (selectionSize === 0 && startPos === code.length) {
          console.log("Uh oh");
          let selectedText = document.getSelection();
          let selectedRange = document.createRange();
          selectedRange.setStart(evt.target.childNodes[0], startPos - 1);
          selectedRange.collapse(true);
          selectedText.removeAllRanges();
          selectedText.addRange(selectedRange);
          evt.target.focus();
        } else {
          console.log("Phew");
        }
      }
      // if (evt.key === "Tab") {
      //   evt.preventDefault();
      //   let before_tab = code.slice(0, this.selectionStart);
      //   let after_tab = code.slice(this.selectionStart, code.length);
      //   let cursor_pos = this.selectionStart + 2;
      //   let tabbedCode = this.normalize(
      //     this.escapeHTML(before_tab + "  " + after_tab),
      //   );
      //   this.visualizer.innerHTML = this.escapeHTML(tabbedCode);
      //   this.editor.innerHTML = this.escapeHTML(tabbedCode);
      //   Prism.highlightElement(this.visualizer);
      //   this.code = tabbedCode;
      //   let selectedText = document.getSelection();
      //   let selectedRange = document.createRange();
      //   selectedRange.setStart(evt.target.childNodes[0], cursor_pos);
      //   selectedRange.collapse(true);
      //   selectedText.removeAllRanges();
      //   selectedText.addRange(selectedRange);
      //   evt.target.focus();
      //   this.dirty = true;
      // }
    }

    onCode(evt) {
      this.error = null;

      let code = this.normalize(this.escapeHTML(evt.target.innerText));
      let inputSize = code.length - this.code.length;
      this.visualizer.innerHTML = code;
      this.editor.innerHTML = code;

      Prism.highlightElement(this.visualizer);
      this.code = code;
      this.dirty = true;

      let selectedText = document.getSelection();
      let selectedRange = document.createRange();
      let selectionTarget = evt.target.childNodes[0];

      if (!!selectionTarget) {
        selectedRange.setStart(
          selectionTarget,
          Math.min(
            selectionTarget.length,
            Math.max(0, this.selectionStart + inputSize),
          ),
        );
        selectedRange.collapse(true);
        selectedText.removeAllRanges();
        selectedText.addRange(selectedRange);
      }
      evt.target.focus();
    }

    onScroll(evt) {
      this.querySelector(".code-box pre").scrollTop = evt.target.scrollTop;
    }

    onSave() {
      // let script = this.app.scripts[this.idx];

      // try {
      //   this.app.updateScript(script.id, this.label, this.code);
      // } catch (err) {
      //   this.error = err;
      // }

      this.save(this.label, this.code);
      this.dirty = false;
    }

    onCancel() {
      document.body.removeChild(document.querySelector("script-editor"));
      // this.parentNode.removeChild(this);
    }
  }
</script>
